{"ast":null,"code":"var _jsxFileName = \"/Users/haileyhansard/Dropbox/LAMBDA SCHOOL/LambdaWork/CS/Week4BuildWeek/conways-game-of-life/game-of-life/src/Components/App.js\";\nimport React, { useState, useEffect, useCallback, useRef } from 'react';\nimport produce from 'immer';\nimport './App.css';\nimport Grid from './Grid';\nimport GameControls from './GameControls';\nimport { presets } from './PresetConfigurations';\nimport PresetConfigurations from './PresetConfigurations';\nconst numRows = 25;\nconst numCols = 25; //these 8 operations represent the movements of the neighbors. subtract 1 to go up a row, increase the row value to go down one.\n\nconst operations = [[0, 1], [0, -1], [1, -1], [-1, 1], [1, 1], [-1, -1], [1, 0], [-1, 0]]; //generate initial empty grid with equal number of rows/columns\n\nconst generateEmptyGrid = numRows => {\n  const rows = []; //array of rows\n\n  for (let i = 0; i < numRows; i++) {\n    const row = [];\n\n    for (let k = 0; k < numRows; k++) {\n      row.push(0); //row of zeros\n    }\n\n    rows.push(row); //add initialized rows onto rows array\n    //0 means dead, 1 means alive\n  }\n\n  return rows;\n};\n\nfunction App() {\n  const [numRows, setNumRows] = useState(25);\n  const [grid, setGrid] = useState(generateEmptyGrid(numRows));\n  const [generation, setGeneration] = useState(0);\n  const [speed, setSpeed] = useState(100);\n  const [running, setRunning] = useState(false); //when button is clicked, running the simulation is toggled on and off\n  //this will allow 'running' to continue and not change its value unless until intended\n\n  const runningRef = useRef(running);\n  runningRef.current = running;\n  console.log(grid);\n  useEffect(() => {\n    setGrid(generateEmptyGrid());\n  });\n\n  const clearGrid = () => {\n    setGrid(g => {\n      return produce(g, gridCopy => {\n        return gridCopy.map(row => {\n          return row.map(col => {\n            return 0;\n          });\n        });\n      });\n    });\n  };\n\n  const runSimulation = useCallback(() => {\n    // see if not currently running, then return\n    if (!runningRef.current) {\n      return;\n    } //whenever ^^ this is false, it will die, our kill condition for the recursive function\n    // simulate\n\n\n    setGrid(g => {\n      return produce(g, gridCopy => {\n        for (let i = 0; i < numRows; i++) {\n          for (let k = 0; k < numCols; k++) {\n            let neighbors = 0;\n            operations.forEach(([x, y]) => {\n              const newI = i + x;\n              const newK = k + y; // check the bounds to make sure it can't go farther than the grid boundaries\n\n              if (newI >= 0 && newI < numRows && newK >= 0 && newK < numCols) {\n                neighbors += g[newI][newK];\n              }\n            });\n\n            if (neighbors < 2 || neighbors > 3) {\n              gridCopy[i][k] = 0;\n            } else if (g[i][k] === 0 && neighbors === 3) {\n              gridCopy[i][k] = 1;\n            }\n          }\n        }\n      });\n    });\n    setTimeout(runSimulation, 100); //setTimeout for seconds between iterations\n  }, []);\n  return /*#__PURE__*/React.createElement(\"div\", {\n    className: \"App\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 107,\n      columnNumber: 5\n    }\n  }, /*#__PURE__*/React.createElement(\"main\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 108,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"header\", {\n    className: \"App-header\",\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 109,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"h1\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 110,\n      columnNumber: 9\n    }\n  }, \"John Conway's Game of Life\")), /*#__PURE__*/React.createElement(Grid, {\n    grid: grid,\n    setGrid: setGrid,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 112,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"button\", {\n    onClick: () => {\n      const rows = [];\n\n      for (let i = 0; i < numRows; i++) {\n        rows.push(Array.from(Array(numCols), () => Math.random() > 0.7 ? 1 : 0));\n      }\n\n      setGrid(rows);\n    },\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 114,\n      columnNumber: 7\n    }\n  }, \" Randomize\"), /*#__PURE__*/React.createElement(GameControls, {\n    setRunning: setRunning,\n    running: running,\n    runningRef: runningRef,\n    runSimulation: runSimulation,\n    clearGrid: clearGrid,\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 129,\n      columnNumber: 7\n    }\n  }), /*#__PURE__*/React.createElement(\"div\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 137,\n      columnNumber: 7\n    }\n  }, /*#__PURE__*/React.createElement(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 138,\n      columnNumber: 9\n    }\n  }, \"Presets\")), /*#__PURE__*/React.createElement(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 142,\n      columnNumber: 7\n    }\n  }, \"Generations: \"), /*#__PURE__*/React.createElement(\"h2\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 143,\n      columnNumber: 7\n    }\n  }, \"Rules\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 144,\n      columnNumber: 9\n    }\n  }, \"Any live cell with two or three live neighbors survives.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 145,\n      columnNumber: 9\n    }\n  }, \"Any dead cell with three live neighbors becomes a live cell.\"), /*#__PURE__*/React.createElement(\"p\", {\n    __self: this,\n    __source: {\n      fileName: _jsxFileName,\n      lineNumber: 146,\n      columnNumber: 9\n    }\n  }, \"All other live cells die in the next generation. Similarly, all other dead cells remain dead.\"))) //end div for App\n  ;\n}\n\n;\nexport default App;","map":{"version":3,"sources":["/Users/haileyhansard/Dropbox/LAMBDA SCHOOL/LambdaWork/CS/Week4BuildWeek/conways-game-of-life/game-of-life/src/Components/App.js"],"names":["React","useState","useEffect","useCallback","useRef","produce","Grid","GameControls","presets","PresetConfigurations","numRows","numCols","operations","generateEmptyGrid","rows","i","row","k","push","App","setNumRows","grid","setGrid","generation","setGeneration","speed","setSpeed","running","setRunning","runningRef","current","console","log","clearGrid","g","gridCopy","map","col","runSimulation","neighbors","forEach","x","y","newI","newK","setTimeout","Array","from","Math","random"],"mappings":"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","sourcesContent":["import React, { useState, useEffect, useCallback, useRef } from 'react';\nimport produce from 'immer';\nimport './App.css';\n\nimport Grid from './Grid';\nimport GameControls from './GameControls';\nimport {presets} from './PresetConfigurations';\nimport PresetConfigurations from './PresetConfigurations';\n\nconst numRows = 25;\nconst numCols = 25;\n\n//these 8 operations represent the movements of the neighbors. subtract 1 to go up a row, increase the row value to go down one.\nconst operations = [\n  [0, 1],\n  [0, -1],\n  [1, -1],\n  [-1, 1],\n  [1,1],\n  [-1, -1],\n  [1, 0],\n  [-1, 0]\n];\n\n//generate initial empty grid with equal number of rows/columns\nconst generateEmptyGrid = numRows => {\n  const rows = []; //array of rows\n  for (let i = 0; i < numRows; i++) {\n    const row = [];\n    for (let k = 0; k < numRows; k++) {\n      row.push(0) //row of zeros\n    }\n    rows.push(row); //add initialized rows onto rows array\n    //0 means dead, 1 means alive\n  }\n\n  return rows;\n};\n\nfunction App() {\n  const [numRows, setNumRows] = useState(25);\n  const [grid, setGrid] = useState(generateEmptyGrid(numRows));\n  const [generation, setGeneration] = useState(0);\n  const [speed, setSpeed] = useState(100);\n  const [running, setRunning] = useState(false); //when button is clicked, running the simulation is toggled on and off\n  \n  //this will allow 'running' to continue and not change its value unless until intended\n  const runningRef = useRef(running); \n  runningRef.current = running\n\n  console.log(grid);\n\n  useEffect(() => {\n    setGrid(generateEmptyGrid())\n  })\n  \n  const clearGrid = () => {\n    setGrid(g => {\n      return produce(g, gridCopy => {\n        return gridCopy.map(row => {\n          return row.map(col => {\n            return 0;\n          })\n        })\n      })\n    })\n  }\n  \n\n  const runSimulation = useCallback(() => {\n    // see if not currently running, then return\n    if (!runningRef.current) {\n      return;\n    } \n    //whenever ^^ this is false, it will die, our kill condition for the recursive function\n    \n    // simulate\n    setGrid(g => {\n      return produce(g, gridCopy => {\n        for (let i = 0; i < numRows; i++) {\n          for (let k = 0; k < numCols; k++) {\n            let neighbors = 0;\n            operations.forEach(([x, y]) => {\n              const newI = i + x;\n              const newK = k + y;\n              // check the bounds to make sure it can't go farther than the grid boundaries\n              if (newI >= 0 && newI < numRows && newK >= 0 && newK < numCols) {\n                neighbors += g[newI][newK];\n              }\n            });\n\n            if (neighbors < 2 || neighbors > 3) {\n              gridCopy[i][k] = 0;\n            } else if (g[i][k] === 0 && neighbors === 3) {\n              gridCopy[i][k] = 1;\n            }\n          }\n        }\n      });\n    });\n    \n    setTimeout(runSimulation, 100);\n    //setTimeout for seconds between iterations\n  }, []);\n\n  return (\n    <div className=\"App\">\n      <main>\n      <header className=\"App-header\">\n        <h1>John Conway's Game of Life</h1>\n      </header>\n      <Grid grid={grid} setGrid={setGrid} />\n      \n      <button\n        onClick={() => {\n          const rows = [];\n          for (let i = 0; i < numRows; i++) {\n            rows.push(\n              Array.from(Array(numCols), () => (Math.random() > 0.7 ? 1 : 0))\n              );\n            }\n            \n            setGrid(rows);\n          }}\n          > Randomize\n      </button>\n      \n      \n      <GameControls \n        setRunning={setRunning}\n        running={running}\n        runningRef={runningRef}\n        runSimulation={runSimulation}\n        clearGrid={clearGrid}\n      />\n\n      <div>\n        <h2>Presets</h2>\n      </div>\n\n\n      <h2>Generations: {}</h2>\n      <h2>Rules</h2>\n        <p>Any live cell with two or three live neighbors survives.</p>\n        <p>Any dead cell with three live neighbors becomes a live cell.</p>\n        <p>All other live cells die in the next generation. Similarly, all other dead cells remain dead.</p>\n      </main>\n    </div> //end div for App\n  );\n};\n\nexport default App;\n"]},"metadata":{},"sourceType":"module"}